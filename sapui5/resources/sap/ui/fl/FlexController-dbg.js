/*
 * ! SAP UI development toolkit for HTML5 (SAPUI5)

(c) Copyright 2014-2016 SAP SE. All rights reserved
 */
/* global Promise */

sap.ui.define([
	"jquery.sap.global",
	"sap/ui/fl/Persistence",
	"sap/ui/fl/registry/ChangeRegistry",
	"sap/ui/fl/Utils",
	"sap/ui/fl/LrepConnector",
	"sap/ui/fl/Change",
	"sap/ui/fl/Cache",
	"sap/ui/fl/registry/Settings",
	"sap/ui/fl/ChangePersistenceFactory",
	"sap/ui/core/mvc/View",
	"sap/ui/fl/changeHandler/JsControlTreeModifier",
	"sap/ui/fl/changeHandler/XmlTreeModifier",
	"sap/ui/fl/context/ContextManager"
], function (jQuery, Persistence, ChangeRegistry, Utils, LrepConnector, Change, Cache, FlexSettings, ChangePersistenceFactory, View, JsControlTreeModifier, XmlTreeModifier, ContextManager) {
	"use strict";

	/**
	 * Retrieves changes (LabelChange, etc.) for a sap.ui.core.mvc.View and applies these changes
	 *
	 * @param {string} sComponentName - the component name the flexibility controller is responsible for
	 * @constructor
	 * @class
	 * @alias sap.ui.fl.FlexController
	 * @experimental Since 1.27.0
	 * @author SAP SE
	 * @version 1.38.33
	 */
	var FlexController = function (sComponentName) {
		this._oChangePersistence = undefined;
		this._sComponentName = sComponentName || "";
		if (this._sComponentName) {
			this._createChangePersistence();
		}
	};

	/**
	 * Sets the component name of the FlexController
	 *
	 * @param {String} sComponentName The name of the component
	 * @public
	 */
	FlexController.prototype.setComponentName = function (sComponentName) {
		this._sComponentName = sComponentName;
		this._createChangePersistence();
	};

	/**
	 * Returns the component name of the FlexController
	 *
	 * @returns {String} the name of the component
	 * @public
	 */
	FlexController.prototype.getComponentName = function () {
		return this._sComponentName;
	};

	/**
	 * Create a change
	 *
	 * @param {object} oChangeSpecificData property bag (nvp) holding the change information (see sap.ui.fl.Change#createInitialFileContent
	 *        oPropertyBag). The property "packageName" is set to $TMP and internally since flex changes are always local when they are created.
	 * @param {sap.ui.core.Control} oControl - control for which the change will be added
	 * @returns {sap.ui.fl.Change} the created change
	 * @public
	 */
	FlexController.prototype.createChange = function (oChangeSpecificData, oControl) {

		var oChangeFileContent, oChange, ChangeHandler;

		if (!oControl) {
			throw new Error("A flexiblity change cannot be created without a targeted control");
		}

		var aCurrentDesignTimeContext = ContextManager._getContextIdsFromUrl();

		if (aCurrentDesignTimeContext.length > 1) {
			throw new Error("More than one DesignTime Context is currently active");
		}

		var oAppComponent = Utils.getAppComponentForControl(oControl);
		if (!oAppComponent) {
			throw new Error("No Application Component found - to offer flexibility the control with the id '" + oControl.getId() + "' has to have a valid relation to its owning application component.");
		}

		var sControlId = oControl.getId();

		if (!oChangeSpecificData.selector) {
			oChangeSpecificData.selector = {};
		}

		// differentiate between controls containing the app component id as a prefix and others
		if (Utils.hasLocalIdSuffix(oControl, oAppComponent)) {
			// get local Id for control at root component and use it as selector id

			var sLocalId = oAppComponent.getLocalId(sControlId);
			if (!sLocalId) {
				throw new Error("Generated id attribute found - to offer flexibility a stable control id is needed to assign the changes to, but for this control the id was generated by SAPUI5 " + oControl.getId());
			}
			oChangeSpecificData.selector.id = sLocalId;
			oChangeSpecificData.selector.idIsLocal = true;

		} else {
			oChangeSpecificData.selector.id = sControlId;
			oChangeSpecificData.selector.idIsLocal = false;
		}

		var oAppDescr = Utils.getAppDescriptor(oControl);
		var sComponentName = this.getComponentName();
		oChangeSpecificData.reference = sComponentName; //in this case the component name can also be the value of sap-app-id
		if (oAppDescr && oAppDescr["sap.app"]) {
			oChangeSpecificData.componentName = oAppDescr["sap.app"].componentName || oAppDescr["sap.app"].id;
		} else {
			//fallback in case no appdescriptor is available (e.g. during unit testing)
			oChangeSpecificData.componentName = sComponentName;
		}
		oChangeSpecificData.packageName = "$TMP"; // first a flex change is always local, until all changes of a component are made transportable

		oChangeSpecificData.context = aCurrentDesignTimeContext.length === 1 ? aCurrentDesignTimeContext[0] : "";

		oChangeFileContent = Change.createInitialFileContent(oChangeSpecificData);
		oChange = new Change(oChangeFileContent);
		// for getting the change handler the control type and the change type are needed
		var sControlType = Utils.getControlType(oControl);
		ChangeHandler = this._getChangeHandler(oChange, sControlType);
		if (ChangeHandler) {
			ChangeHandler.completeChangeContent(oChange, oChangeSpecificData, {
				modifier: JsControlTreeModifier,
				appComponent: oAppComponent
			});
		} else {
			throw new Error('Change handler could not be retrieved for change ' + JSON.stringify(oChangeSpecificData));
		}

		return oChange;
	};

	/**
	 * Adds a change to the flex persistence (not yet saved). Will be saved with #saveAll.
	 *
	 * @param {object} oChangeSpecificData property bag (nvp) holding the change information (see sap.ui.fl.Change#createInitialFileContent
	 *        oPropertyBag). The property "packageName" is set to $TMP and internally since flex changes are always local when they are created.
	 * @param {sap.ui.core.Control} oControl control for which the change will be added
	 * @returns {sap.ui.fl.Change} the created change
	 * @public
	 */
	FlexController.prototype.addChange = function (oChangeSpecificData, oControl) {
		var oChange = this.createChange(oChangeSpecificData, oControl);
		this._oChangePersistence.addChange(oChange);
		return oChange;
	};

	/**
	 * Adds an already prepared change to the flex persistence (not yet saved). This method will not call
	 * cheateChange again, but expects an fully computed and appliable change.
	 * Will be saved with #saveAll.
	 *
	 * @param {object} oChange property bag (nvp) holding the change information (see sap.ui.fl.Change#createInitialFileContent
	 *        oPropertyBag). The property "packageName" is set to $TMP and internally since flex changes are always local when they are created.
	 * @param {sap.ui.core.Control} oControl control for which the change will be added
	 * @returns {sap.ui.fl.Change} the created change
	 * @public
	 */
	FlexController.prototype.addPreparedChange = function (oChange) {
		this._oChangePersistence.addChange(oChange);
		return oChange;
	};

	/**
	 * Creates a new change and applies it immediately
	 *
	 * @param {object} oChangeSpecificData The data specific to the change, e.g. the new label for a RenameField change
	 * @param {sap.ui.core.Control} oControl The control where the change will be applied to
	 * @public
	 */
	FlexController.prototype.createAndApplyChange = function (oChangeSpecificData, oControl) {
		var oChange = this.addChange(oChangeSpecificData, oControl);
		try {
			var mPropertyBag = {
				modifier: JsControlTreeModifier,
				appComponent: Utils.getAppComponentForControl(oControl)
			};
			this._checkTargetAndApplyChange(oChange, oControl, mPropertyBag);
		} catch (oException) {
			this._oChangePersistence.deleteChange(oChange);
			throw oException;
		}
	};

	/**
	 * Saves all changes of a persistence instance.
	 *
	 * @returns {Promise} resolving with an array of responses or rejecting with the first error
	 * @public
	 */
	FlexController.prototype.saveAll = function () {
		return this._oChangePersistence.saveDirtyChanges();
	};

	/**
	 * Loads and applies all changes for the specified js control tree view
	 *
	 * @param {object} oView - the view to process as JS control tree
	 * @param {boolean} bUnmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {boolean} mPropertyBag.cleanMergedChangesAfterwards - flag if merged changes array should be cleaned afterwards for upcomming merges
	 * @returns {Promise} without parameters. Promise resolves once all changes of the view have been applied
	 * @public
	 */
	FlexController.prototype.processView = function (oView, bUnmergedChangesOnly) {
		var mPropertyBag = {
			unmergedChangesOnly: bUnmergedChangesOnly
		};

		return this.processJsView(oView, mPropertyBag);
	};

	/**
	 * Loads and applies all changes for the specified js control tree view
	 *
	 * @param {object) oView - the view to process as JS control tree
	 * @param {boolean} mPropertyBag.unmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {boolean} mPropertyBag.cleanMergedChangesAfterwards - flag if merged changes array should be cleaned afterwards for upcomming merges
	 * @returns {Promise} without parameters. Promise resolves once all changes of the view have been applied
	 * @public
	 */
	FlexController.prototype.processJsView = function (oView, mPropertyBag) {
		mPropertyBag.appComponent = Utils.getAppComponentForControl(oView);
		mPropertyBag.appDescriptor = Utils.getAppDescriptor(oView);
		mPropertyBag.modifier = JsControlTreeModifier;
		mPropertyBag.view = oView;

		return this.processViewByModifier(mPropertyBag);
	};

	/**
	 * Loads and applies all changes for the specified xml tree view
	 *
	 * @param {object} oView - the view to process as XML tree
	 * @param {string} mPropertyBag.viewId - id of the processed view
	 * @param {string} mPropertyBag.appComponent - app component
	 * @param {boolean} mPropertyBag.unmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {boolean} mPropertyBag.cleanMergedChangesAfterwards - flag if merged changes array should be cleaned afterwards for upcomming merges
	 * @returns {Promise} without parameters. Promise resolves once all changes of the view have been applied
	 * @public
	 */
	FlexController.prototype.processXmlView = function (oView, mPropertyBag) {
		var oComponent = sap.ui.getCore().getComponent(mPropertyBag.componentId);
		var oAppComponent = Utils.getAppComponentForControl(oComponent);
		var oManifest = oComponent.getManifest();

		mPropertyBag.appComponent = oAppComponent;
		mPropertyBag.appDescriptor = oManifest;
		mPropertyBag.modifier = XmlTreeModifier;
		mPropertyBag.view = oView;

		return this.processViewByModifier(mPropertyBag);
	};

	/**
	 * Loads and applies all changes for the specified view
	 *
	 * @param {object} mPropertyBag.view - the view to process as XML tree
	 * @param {string} mPropertyBag.viewId - id of the processed view
	 * @param {string} mPropertyBag.appComponent - app component
	 * @param {boolean} mPropertyBag.unmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {boolean} mPropertyBag.cleanMergedChangesAfterwards - flag if merged changes array should be cleaned afterwards for upcomming merges
	 * @param {object} mPropertyBag.appDescriptor - app descriptor containing the metadata of the current application
	 * @param {string} siteId - id of the flp site containing this application
	 * @returns {Promise} without parameters. Promise resolves once all changes of the view have been applied
	 * @public
	 */
	FlexController.prototype.processViewByModifier = function (mPropertyBag) {
		// by default on a xml view only handle ALL changes and JS only unmerged changes
		mPropertyBag.unmergedChangesOnly = mPropertyBag.unmergedChangesOnly || mPropertyBag.modifier === JsControlTreeModifier;
		// by default remove the array of merged changes for further view processing (i.e. after recreating the view by FLP)
		mPropertyBag.cleanMergedChangesAfterwards = mPropertyBag.cleanMergedChangesAfterwards || mPropertyBag.modifier === JsControlTreeModifier;
		mPropertyBag.viewId = mPropertyBag.modifier.getId(mPropertyBag.view);
		mPropertyBag.siteId = Utils.getSiteId(mPropertyBag.appComponent);

		var oGetFlexSettingsPromise = FlexSettings.getInstance(this.getComponentName(), mPropertyBag);
		return oGetFlexSettingsPromise.then(
			this._resolveGetFlexSettingsInstance.bind(this, mPropertyBag),
			this._handlePromiseChainError.bind(this, mPropertyBag.view)
		);
	};

	FlexController.prototype._resolveGetFlexSettingsInstance = function (mPropertyBag) {
		var oGetChangesPromise;

		if (!mPropertyBag.unmergedChangesOnly) {
			oGetChangesPromise = this._oChangePersistence.getChangesForView(mPropertyBag);
		} else {
			oGetChangesPromise = this._oChangePersistence.getUnmergedChangesForView(mPropertyBag);
		}

		return oGetChangesPromise.then(
			this._resolveGetChangesForView.bind(this, mPropertyBag)
		);
	};


	/**
	 * Looping over all retrieved flexibility changes and applying them onto the targeted control within the view
	 *
	 * @param {object} mPropertyBag.view - the view to process
	 * @param {string} mPropertyBag.viewId - id of the processed view
	 * @param {string} mPropertyBag.appComponent - app component
	 * @param {object} mPropertyBag.modifier - polymorph reuse operations handling the changes on the given view type
	 * @param {boolean} mPropertyBag.unmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {boolean} mPropertyBag.cleanMergedChangesAfterwards - flag if merged changes array should be cleaned afterwards for upcomming merges
	 * @param {object} mPropertyBag.appDescriptor - app descriptor containing the metadata of the current application
	 * @param {string} mPropertyBag.siteId - id of the flp site containing this application
	 * @param {sap.ui.fl.Change[]} aChanges - list of flexibilty changes on controls for the current processed view
	 * @returns {object} view - view object with all applied changes
	 * @private
	 */
	FlexController.prototype._resolveGetChangesForView = function (mPropertyBag, aChanges) {
		if (!mPropertyBag.unmergedChangesOnly) {
			this._oChangePersistence.clearMergedChanges();
		}

		if (!Array.isArray(aChanges)) {
			jQuery.sap.log("No list of changes was passed for processing the flexibility on view: " + mPropertyBag.view);
			return [];
		}

		aChanges.forEach(function (oChange) {
			try {
				var oSelector = this._getSelectorOfChange(oChange);

				if (!oSelector || !oSelector.id) {
					throw new Error("No selector in change found or no selector ID.");
				}

				var oControl = mPropertyBag.modifier.bySelector(oSelector, mPropertyBag.appComponent, mPropertyBag.view);

				if (!oControl) {
					throw new Error("A flexibility change tries to change a non existing control");
				}

				this._checkTargetAndApplyChange(oChange, oControl, mPropertyBag);
			} catch (oException) {
				this._logApplyChangeError(oException, oChange);
			}
		}.bind(this));

		if (mPropertyBag.cleanMergedChangesAfterwards) {
			this._oChangePersistence.setMergedChanges([]);
		}

		return mPropertyBag.view;
	};

	FlexController.prototype._getSelectorOfChange = function (oChange) {
		if (!oChange || !oChange.getSelector) {
			return undefined;
		}
		return oChange.getSelector();
	};

	FlexController.prototype._logApplyChangeError = function (oException, oChange) {
		var oDefinition = oChange.getDefinition();
		var sChangeType = oDefinition.changeType;
		var sTargetControlId = oDefinition.selector.id;
		var fullQualifiedName = oDefinition.namespace + oDefinition.fileName + "." + oDefinition.fileType;

		var sWarningMessage = "A flexiblity change could not be applied.";
		sWarningMessage += "\nThe displayed UI might not be displayed as intedend.";
		if (oException.message) {
			sWarningMessage += "\n   occurred error message: '" + oException.message + "'";
		}
		sWarningMessage += "\n   type of change: '" + sChangeType + "'";
		sWarningMessage += "\n   LRep location of the change: " + fullQualifiedName;
		sWarningMessage += "\n   id of targeted control: '" + sTargetControlId + "'";

		Utils.log.warning(sWarningMessage, undefined, "sap.ui.fl.FlexController");
	};

	/**
	 * Applying a specific change on the passed control
	 *
	 * @param {sap.ui.fl.Change} oChange - change object which should be applied on the passed control
	 * @param {sap.ui.core.Control} oControl - control which is the target of the passed change
	 * @param {object} mPropertyBag
	 * @param {object} mPropertyBag.view - the view to process
	 * @param {object} mPropertyBag.modifier - polymorph reuse operations handling the changes on the given view type
	 * @param {boolean} mPropertyBag.unmergedChangesOnly - flag if view should only processed with changes flagged as unmerged within the ChangePersistence
	 * @param {object} mPropertyBag.appDescriptor - app descriptor containing the metadata of the current application
	 * @param {string} siteId - id of the flp site containing this application
	 * @private
	 */
	FlexController.prototype._checkTargetAndApplyChange = function (oChange, oControl, mPropertyBag) {
		var sControlType = mPropertyBag.modifier.getControlType(oControl);
		var oChangeHandler = this._getChangeHandler(oChange, sControlType);

		if (!oChangeHandler) {
			throw (new Error("A change handler for the given change type does not exist."));
		}

		var bWasMerged = oChangeHandler.applyChange(oChange, oControl, mPropertyBag);

		if (bWasMerged) {
			this._oChangePersistence.addMergedChange(oChange.getFullFileIdentifier());
		}
	};

	FlexController.prototype._handlePromiseChainError = function (oView, oError) {
		Utils.log.error('Error processing view ' + oError);
		return oView;
	};

	FlexController.prototype._getTargetControlIdOfChange = function (oChange) {
		if (!oChange) {
			return undefined;
		}
		var oSelector = oChange.getSelector();
		if (oSelector) {
			return oSelector.id;
		}

		return undefined;
	};

	/**
	 * Retrieves the corresponding change handler for the change and applies the change to the control
	 *
	 * @param {sap.ui.fl.Change} oChange Change instance
	 * @param {sap.ui.core.Control} oControl Control instance
	 * @public
	 * @deprecated
	 */
	FlexController.prototype.applyChange = function (oChange, oControl) {
		var sControlType = Utils.getControlType(oControl);
		var oChangeHandler = this._getChangeHandler(oChange, sControlType);
		if (!oChangeHandler) {
			if (oChange && oControl) {
				Utils.log.warning("Change handler implementation for change not found - Change ignored");
			}
			return;
		}

		try {
			oChangeHandler.applyChange(oChange, oControl);
		} catch (ex) {
			this._setMergeError(true);
			Utils.log.error("Change could not be applied. Merge error detected.");
			throw ex;
		}
	};

	/**
	 * Retrieves the <code>sap.ui.fl.registry.ChangeRegistryItem</code> for the given change and control
	 *
	 * @param {sap.ui.fl.Change} oChange - Change instance
	 * @param {string} sControlType name of the ui5 control type i.e. sap.m.Button
	 * @returns {sap.ui.fl.changeHandler.Base} the change handler. Undefined if not found.
	 * @private
	 */
	FlexController.prototype._getChangeHandler = function (oChange, sControlType) {
		var oChangeTypeMetadata, fChangeHandler;

		oChangeTypeMetadata = this._getChangeTypeMetadata(oChange, sControlType);
		if (!oChangeTypeMetadata) {
			return undefined;
		}

		fChangeHandler = oChangeTypeMetadata.getChangeHandler();
		return fChangeHandler;
	};

	/**
	 * Retrieves the <code>sap.ui.fl.registry.ChangeRegistryItem</code> for the given change and control
	 *
	 * @param {sap.ui.fl.Change} oChange Change instance
	 * @param {string} sControlType name of the ui5 control type i.e. sap.m.Button
	 * @returns {sap.ui.fl.registry.ChangeTypeMetadata} the registry item containing the change handler. Undefined if not found.
	 * @private
	 */
	FlexController.prototype._getChangeTypeMetadata = function (oChange, sControlType) {
		var oChangeRegistryItem, oChangeTypeMetadata;

		oChangeRegistryItem = this._getChangeRegistryItem(oChange, sControlType);
		if (!oChangeRegistryItem || !oChangeRegistryItem.getChangeTypeMetadata) {
			return undefined;
		}

		oChangeTypeMetadata = oChangeRegistryItem.getChangeTypeMetadata();
		return oChangeTypeMetadata;
	};

	/**
	 * Retrieves the <code>sap.ui.fl.registry.ChangeRegistryItem</code> for the given change and control
	 *
	 * @param {sap.ui.fl.Change} oChange Change instance
	 * @param {string} sControlType name of the ui5 control type i.e. sap.m.Button
	 * @returns {sap.ui.fl.registry.ChangeRegistryItem} the registry item containing the change handler. Undefined if not found.
	 * @private
	 */
	FlexController.prototype._getChangeRegistryItem = function (oChange, sControlType) {
		var sChangeType, oChangeRegistryItem, sLayer;
		if (!oChange || !sControlType) {
			return undefined;
		}

		sChangeType = oChange.getChangeType();

		if (!sChangeType || !sControlType) {
			return undefined;
		}

		sLayer = oChange.getLayer();

		oChangeRegistryItem = this._getChangeRegistry().getRegistryItems({
			"changeTypeName": sChangeType,
			"controlType": sControlType,
			"layer": sLayer
		});
		if (oChangeRegistryItem && oChangeRegistryItem[sControlType] && oChangeRegistryItem[sControlType][sChangeType]) {
			return oChangeRegistryItem[sControlType][sChangeType];
		} else if (oChangeRegistryItem && oChangeRegistryItem[sControlType]) {
			return oChangeRegistryItem[sControlType];
		} else {
			return oChangeRegistryItem;
		}
	};

	/**
	 * Returns the change registry
	 *
	 * @returns {sap.ui.fl.registry.ChangeRegistry} Instance of the change registry
	 * @private
	 */
	FlexController.prototype._getChangeRegistry = function () {
		var oInstance = ChangeRegistry.getInstance();
		// make sure to use the most current flex settings that have been retrieved during processView
		oInstance.initSettings(this.getComponentName());
		return oInstance;
	};

	/**
	 * Retrieves the changes for the complete UI5 component
	 * @param {map} mPropertyBag - (optional) contains additional data that are needed for reading of changes
	 * - appDescriptor that belongs to actual component
	 * - siteId that belongs to actual component
	 * @returns {Promise} Promise resolves with a map of all {sap.ui.fl.Change} having the changeId as key
	 * @public
	 */
	FlexController.prototype.getComponentChanges = function (mPropertyBag) {
		return this._oChangePersistence.getChangesForComponent(mPropertyBag);
	};

	/**
	 * Creates a new instance of sap.ui.fl.Persistence based on the current component and caches the instance in a private member
	 *
	 * @returns {sap.ui.fl.Persistence} persistence instance
	 * @private
	 */
	FlexController.prototype._createChangePersistence = function () {
		this._oChangePersistence = ChangePersistenceFactory.getChangePersistenceForComponent(this.getComponentName());
		return this._oChangePersistence;
	};

	/**
	 * Discard changes on the server.
	 *
	 * @param {array} aChanges array of {sap.ui.fl.Change} to be discarded
	 * @returns {Promise} promise that resolves without parameters.
	 */
	FlexController.prototype.discardChanges = function (aChanges) {
		var sActiveLayer = Utils.getCurrentLayer(false);
		aChanges.forEach(function (oChange) {
			// only discard changes of the currently active layer (CUSTOMER vs PARTNER vs VENDOR)
			if (oChange && oChange.getLayer && oChange.getLayer() === sActiveLayer) {
				this._oChangePersistence.deleteChange(oChange);
			}
		}.bind(this));

		return this._oChangePersistence.saveDirtyChanges();
	};

	FlexController.prototype.deleteChangesForControlDeeply = function (oControl) {
		return Promise.resolve();
	};

	/**
	 * Set flag if an error has occurred when merging changes
	 *
	 * @returns {Promise} Promise resolved after the merge error flag is set
	 * @private
	 */
	FlexController.prototype._setMergeError = function () {
		return FlexSettings.getInstance(this.getComponentName()).then(function (oSettings) {
			oSettings.setMergeErrorOccured(true);
		});
	};

	return FlexController;
}, true);
