<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="abstract" content="The following section explains some constraints that you have to be aware of when working with the TreeTable."/>
<meta name="description" content="The following section explains some constraints that you have to be aware of when working with the TreeTable."/>

<link rel="stylesheet" type="text/css" href="css/prettify.css?x=37914854839113155"/>
<link rel="stylesheet" type="text/css" href="css/documentation.css?x=37914854839113155"/>
<title>Tree Table: Constraints</title>
  <link rel="stylesheet" type="text/css" href="../../resources/sap/ui/demokit/themes/base/highlight-query-terms.css" />
    <link rel="stylesheet" type="text/css" href="../../resources/sap/ui/demokit/js/google-code-prettify/prettify.css" />
    <script src="../../resources/sap/ui/demokit/js/sdk-pagehelper.js"></script>
  </head>
<body class="" id="loio07deec992cab4912893f2d9ec2f29489">
<div id="wrapper"><div id="container">

	<h1 class="title topictitle1">Tree Table: Constraints</h1>

	
	<div class="body conbody"><p class="shortdesc">The following section explains some constraints that you have to be aware of when
		working with the <span class="keyword apiname">TreeTable</span>. </p>

		<div class="section collapsible"><div class="section_title">Auto-Expand</div><div type="Auto-Expand">
			
			<p class="p">A very common feature request is to initially expand a tree to a given level. Technically,
					<samp class="ph codeph">ODataTreeBinding</samp> can only deliver this feature with the
					<samp class="ph codeph">hierarchy-node-descendant-count-for</samp> annotation. However, we
				recommend not to use this feature with the minimal annotation set, and we strictly
				advise against building a similar feature yourself with application coding.
				The
				preconditions and data structures are far to complex to be manipulated by
				"best-guess" API calls.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Expand All / Expand to Level</div><div type="Expand All / Expand to Level">
			
			<p class="p">When running in <samp class="ph codeph">OperationMode</samp>
				<samp class="ph codeph">Server</samp>,
				you cannot expand all nodes in a tree. The OData protocol (2.0) does not provide a
				mechanism to formulate such a request, but can still perform paging based on
					<samp class="ph codeph">$skip</samp> and <samp class="ph codeph">$top</samp> values. </p>

			<p class="p">When using the <samp class="ph codeph">hierarchy-node-descendant-count-for</samp> annotation, you can set
				the <samp class="ph codeph">numberOfExpandedLevels</samp> to a
				very
				high number so that the back-end implementation takes care of pre-expanding the tree
				to the given level. However, the maximum number of available levels is unknown to
				the application most of the time.</p>

			<p class="p">The only feasible solution is to use <samp class="ph codeph">OperationMode</samp>
				<samp class="ph codeph">Client</samp> and then expand the tree with a
				very
				high number of levels. Be aware that this might affect other features of the
				<samp class="ph codeph">ODataTreeBinding</samp> feature and has serious performance
				implications.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Expand Node To Level / Expand Node Fully</div><div type="Expand Node To Level / Expand Node Fully">
			
			<p class="p">Not supported in any binding configuration. The OData protocol 2.0 does not provide a
				way to formulate back-end requests to retrieve the relevant entities.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Collapse Recursively</div><div type="Collapse Recursively">
			
			<p class="p">You can collapse a subtree recursively by setting the <samp class="ph codeph">collapseRecursive</samp>
				property of the <samp class="ph codeph">TreeTable</samp> to <samp class="ph codeph">true</samp>. However, the
					<samp class="ph codeph">collapseRecursive</samp> property is directly tied to the selection
				behavior. When you recursively collapse a subtree, the selection of all nodes in
				that subtree is lost.</p>

			<p class="p">When you set <samp class="ph codeph">collapseRecursive</samp> to <samp class="ph codeph">false</samp>, the
				selection state of the nodes in the subtree is kept intact.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Selection Behavior</div><div type="Selection Behavior">
			
			<p class="p">The selection behavior of the <samp class="ph codeph">TreeTable</samp> (and
					<samp class="ph codeph">AnalyticalTable</samp> for that matter) is based solely on the
				entities that are known on the client. Therefore, you cannot select entities that
				are not yet loaded to the client. </p>

			<p class="p">The <samp class="ph codeph">TreeTable</samp> provides an index-based API to manipulate the selected
				rows. However, selecting an index that does not hold a valid entity will simply be
				ignored. </p>

			<p class="p">The selected indices are only valid as long as no other operation is performed on the tree. In
				case a node is expanded, collapsed, added, or removed, the indices will become
				invalid and have to be requested from the <samp class="ph codeph">TreeTable</samp> anew. Do not
				create your own application logic to select certain nodes (for example, by finding
				the node via its ID). This kind of logic is bound to fail at some point, as the
				application has even less information about the data than the
					<samp class="ph codeph">ODataTreeBinding</samp> has.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Select All - Mass Change Operations</div><div type="Select All - Mass Change Operations">
			
			<p class="p">When running in <samp class="ph codeph">OperationMode</samp>
				<samp class="ph codeph">Server</samp>, the data sets are not completely loaded on the client, so
				selecting all entities from the UI is not possible. But for mass change operations
				like approving of all orders, it is necessary to also select entities that are not
				currently visible.</p>

			<p class="p">In a <samp class="ph codeph">TreeTable</samp> this behavior is hidden from the user, and yet unknown entries
				are selected automatically when they are loaded from the back end, for example, when
				they are scrolled into view. However, the indices of selected items that are
				retrieved from the <samp class="ph codeph">TreeTable</samp> still include only the indices of
				visible items.</p>

			<p class="p">A simple solution for this would be to get all selected indices and loop over them to change
				all values, but you can already know that everything is selected, by looking at the
					<samp class="ph codeph">selectAll</samp> flag in the <samp class="ph codeph">rowSelectionChange</samp> event
				of the <samp class="ph codeph">TreeTable</samp>. </p>

			<p class="p">A better approach for mass-change operations would be to provide service functions (for
				example, function imports) that allow you to change
				all
				entities except all nodes that are not selected. This information
				can also be gathered from the <samp class="ph codeph">rowSelectionChange</samp> event of the
					<samp class="ph codeph">TreeTable</samp>. This way, you keep the number of back-end requests
				to a minimum and you do not run into client-side problems.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Filtering and Searching</div><div type="Filtering and Searching">
			
			<p class="p">For services that expose the <samp class="ph codeph">hierarchy-node-descendant-count-for</samp> annotation,
				the filtering behavior is completely under the control of the application and can be
				implemented in the service layer. The <samp class="ph codeph">TreeTable</samp> and the
					<samp class="ph codeph">ODataTreeBinding</samp> are completely decoupled from filtering and
				searching.</p>

		</div></div>

		<div class="section collapsible"><div class="section_title">Scrolling</div><div type="Scrolling">
			
			<p class="p">Don't use of the programmatic scrolling API of the <samp class="ph codeph">TreeTable</samp>. Each scrolling
				action can lead to multiple back-end requests, depending on the internal state of
				the <samp class="ph codeph">ODataTreeBinding</samp>. This is not usually intended when
				programmatic scrolling is triggered.</p>

			<p class="p">Scrolling to a specific entity is also technically not feasible, as the correct location of
				this entity is not known to the data binding. The same is true for the application.
				Especially in customer systems, in which data and data structures change frequently,
				locating a single entity from the client is not possible.</p>

			<p class="p">Do not build any application logic to find single entities in the overall tree structure. Such
				logic is bound to fail, as the data keeps changing and the algorithms do not have
				the necessary insight into the data structures to know what is really going on
				internally. The <samp class="ph codeph">ODataTreeBinding</samp> and the <samp class="ph codeph">TreeTable</samp>
				do not support such self-made algorithms.</p>

		</div></div>

	</div>

</div></div>

</body>
</html>