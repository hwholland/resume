<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="abstract" content="Composite controls are a means to save time and effort by reusing existing controls for the implementation."/>
<meta name="description" content="Composite controls are a means to save time and effort by reusing existing controls for the implementation."/>

<link rel="stylesheet" type="text/css" href="css/prettify.css?x=9755585587127592"/>
<link rel="stylesheet" type="text/css" href="css/documentation.css?x=9755585587127592"/>
<title>Standard Composite Controls</title>
  <link rel="stylesheet" type="text/css" href="../../resources/sap/ui/demokit/themes/base/highlight-query-terms.css" />
    <link rel="stylesheet" type="text/css" href="../../resources/sap/ui/demokit/js/google-code-prettify/prettify.css" />
    <script src="../../resources/sap/ui/demokit/js/sdk-pagehelper.js"></script>
  </head>
<body class="" id="loioc1512f6ce1454ff1913e3857bad56392">
<div id="wrapper"><div id="container">

	<h1 class="title topictitle1">Standard Composite Controls</h1>

	
	<div class="body"><p class="shortdesc">Composite controls are a means to save time and effort by reusing existing controls for
		the implementation.</p>

		<p class="p">For application developers, the composite control is a black box, therefore, an application
			developer cannot distinguish a composite control from native (non-composite) controls.
			As the application developer can not distinguish the controls, the control developer can
			change the implementation later and avoid composition (or the other way around). For
			existing uses of the respective control, this change is fully compatible.</p>

		<div class="note note"><span class="notetitle">Note</span> 
			<p class="p">If you do <span class="ph emphasis emphasis">not</span> intend to re-use a control in several places, a composite
				control may not be your best choice. Composite controls are best suited for
				(massive) re-use and for a public API that shields the application developer from
				its inner workings. If these are not your requirements, consider to use other
				techniques of factoring out common parts within your application. You can, for
				example, simply write an XML fragment or a function returning the root of some
				control tree.</p>

		</div>

		<div class="section"><div class="section_title">Simple Example: Search Field</div><div type="Simple Example: Search Field"><p class="p">To create a composite control, you
				start with crafting its API including properties, events, aggregations, and so on as
				you do it for any other control. Choose either element or control as base type. The
				following simple example combines an input field with a button that we call "search
				field". To the outside world, it offers an editable value and can fire a search
				event.</p>
<img class="image" id="loioc1512f6ce1454ff1913e3857bad56392__image_dnf_dph_5q" src="loiofd6475b8d1fd4b75bad61b7dc2e8ce3c_LowRes.png"/><div class="sectiondiv subsection">
				<p class="p subsectiontitle">API</p>

				<p class="p">As any other control, you can describe composite controls via the JavaScript control
					definition API, see <a class="xref" href="8dcab0011d274051808f959800cabf9f.html" title="You can create own content for OpenUI5. To develop controls in JavaScript, you can either extend existing controls or create new ones.">Developing Controls</a> and
					the following example.</p>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">sap.ui.core.Control.extend("SearchField", {
  metadata : {
    properties : {
       "value" : "string"
    },
    aggregations: {
       "_input" : {type : "sap.m.Input", multiple : false, visibility: "hidden"},
       "_btn" : {type : "sap.m.Button", multiple : false, visibility: "hidden"}
    },
    events: {
       "search" : {}
    }
  }
});</pre></div>

				<p class="p">The two aggregations with visibility set to <samp class="ph codeph">hidden</samp> are defined
					in the code snippets above. These aggregations are used to hold the inner
					controls. Aggregations are used to define a parent-child relationship between a
					parent control and its children (controls or elements). The knowledge about this
					relationship is, for example, relevant for the <span class="ph"><span class="ph pname">OpenUI5</span></span> core to
					dispatch events properly, or to cleanup the children when the parent is
					destroyed. Hidden aggregations are control internal and are used especially to
					register the inner controls within the control hierarchy without making them
					publicly available. Because hidden aggregations are only used internally within
					a composite control for hidden aggregations, no typed <samp class="ph codeph">accessor</samp>
					functions are generated, they are not cloned, and data binding is not
					enabled.</p>

			</div><div class="sectiondiv subsection">
				<p class="p subsectiontitle">Behavior</p>

				<p class="p">The control implementation, that is, its behavior, contains the code for
					initialization and clean-up hooks as well as glue code for properties and
					events.</p>

			</div><div class="sectiondiv subsection">
				<p class="p subsectiontitle">Init</p>

				<p class="p">The <samp class="ph codeph">init</samp> function contains the composite's parts and stores references to
					them.
					If you want to hide the composite parts, you should <span class="ph emphasis emphasis">not</span>
					assign an ID to those parts, but rather let the framework compute the IDs
					automatically. This reduces the possibility that a
					composite's parts are accessed from outside via the
						<samp class="ph codeph">sap.ui.getCore().byId(...)</samp> function.</p>

				<p class="p">If you have to assign IDs to the composite parts, then you should create those
					IDs by concatenating the main control ID (ID of your composite instance) with a
					single dash (<samp class="ph codeph">-</samp>) and an additional ID for the part like in the
					following example:</p>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">mySearchField-input
mySearchField-btn</pre></div>

				<p class="p">To avoid conflicts with the internal IDs of parts, the part ID
						(<samp class="ph codeph">input</samp> or <samp class="ph codeph">btn</samp> in the example) must be
					prefix-free. That means, it should not contain another dash (for example, don't
					use parts <samp class="ph codeph">input-label</samp> and <samp class="ph codeph">input</samp> at the same
					time). If the control that is used as part <samp class="ph codeph">input</samp> also is a
					composite control and accidentally uses part <samp class="ph codeph">label</samp>, then you'll
					have a conflict between
						<samp class="ph codeph">mySearchField-input</samp><samp class="ph codeph">-label</samp>
						(<samp class="ph codeph">label</samp> part of the <samp class="ph codeph">input</samp>) and your
						<samp class="ph codeph">mySearchField-input-label</samp> artifact
						(<samp class="ph codeph">input-label</samp> part of your composite).</p>

				<div class="note note"><span class="notetitle">Note</span> 
					<p class="p"><span class="ph"><span class="ph pname">OpenUI5</span></span> reserves the single dash
							(<samp class="ph codeph">-)</samp> for composite controls and their parts, a double
						dash (<samp class="ph codeph">--)</samp> is used to combine the ID of views and their
						contained controls and a triple dash (<samp class="ph codeph">---)</samp>is used to
						combine component IDs and the IDs of their owned controls or views.</p>

				</div>

				<p class="p">During the <samp class="ph codeph">init</samp> function, the settings of the composite only
					have their default values. If the application developer has provided some values
					to the constructor, these values will only be set later on. It is, therefore,
					crucial for the correct behavior of your composite control that you implement
					one of the synchronization mechanisms described below.</p>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">/**
 * Initialization hook... creating composite parts
 */
SearchField.prototype.init = function(){
  var that = this;
  this.setAggregation("_input", new sap.m.Input({
    change: function(oEvent){
      that.setProperty("value", oEvent.getParameter("Value"), true /*no re-rendering needed, change originates in HTML*/); //see section Properties for explanation
    }
  }));
  this.setAggregation("_btn", new sap.m.Button({
    text: "Search",
    press: function(){
      that.fireSearch();
    }
  }));
};</pre></div>

			</div><div class="sectiondiv subsection">
				<p class="p subsectiontitle">Exit</p>

				<p class="p">You can use the <samp class="ph codeph">exit</samp> function to clean up your control when it
					is destroyed. You do not need to destroy the inner controls. This is done
					automatically by the framework because the inner controls are kept in hidden
					aggregations.</p>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">/**
 * Clean-up hook... destroying composite parts.
 */
SearchField.prototype.exit = function() {
  //nothing to do here
};</pre></div>

			</div><div class="sectiondiv subsection">
				<p class="p subsectiontitle">Properties</p>

				<p class="p">Changes to settings in the API of a composite control are usually reflected in
					its parts. In the following example, the value property is propagated to the
					input part. To do so, the generated setter for that property is overwritten.
					Make sure that you include the proper implementation which generically sets a
					property inside the element base class, else you would have to override the
					getter also.</p>

				<p class="p">Note how the input's change event is used to update the composite's value
					property. Because the change originated in the HTML input field, no re-rendering
					is needed. This is expressed by the third parameter of the
						<samp class="ph codeph">setProperty</samp> call. This trick is applicable whenever a
					property change does not require a re-rendering on this control level.</p>

				<div class="note note"><span class="notetitle">Note</span> 
					<p class="p">Changing the input part's value triggers a re-rendering of the input.</p>

				</div>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">/**
 * Propagate value to input.
 */
SearchField.prototype.setValue = function(sValue){
    this.setProperty("value", sValue, true /*no re-rendering of whole search field needed*/);
    this.getAggregation("_input").setValue(sValue); // Note: this triggers re-rendering of input!
};</pre></div>

				<p class="p">Propagating the API settings to the parts is usually not as straightforward as
					shown in the example above. If intercepting the changes by overriding the
					setters is not sufficient or too complicated, an alternative approach might be
					to implement a single <samp class="ph codeph">updateAllParts</samp> method and call it at the
					beginning of the renderer of the composite control or in the
						<samp class="ph codeph">onBeforeRendering</samp> hook of the control itself..</p>

			</div><div class="sectiondiv subsection">
				<p class="p subsectiontitle">Renderer</p>

				<p class="p">You can use markup for layouting in the renderer implementation. But at the heart
					of it, you simply delegate (via the render manager) to the composite parts'
					renderers. This is where you really benefit from re-using other controls with
					non-trivial renderers. If you have chosen the <samp class="ph codeph">updateAllParts</samp>
					approach to keep the composite API settings and the settings of the parts in
					sync, make sure that you call <samp class="ph codeph">updateAllParts</samp> before the real
					rendering starts.</p>

				<div class="div_pre_codeblock"><pre class="pre codeblock prettyprint lang-js">SearchFieldRenderer.render = function(oRenderManager, oSearchField) {
  // oSearchField.updateAllParts(); // called depending on your 'sync' approach
  oRenderManager.write("&lt;div"); 
  oRenderManager.writeControlData(oSearchField);
  oRenderManager.addClass("SearchField"); 
  oRenderManager.writeClasses();
  oRenderManager.write("&gt;");
  oRenderManager.renderControl(oSearchField.getAggregation("_input"));
  oRenderManager.renderControl(oSearchField.getAggregation("_btn"));
  oRenderManager.write("&lt;/div&gt;");
};</pre></div>

			</div></div></div>

	</div>

</div></div>

</body>
</html>